{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "01. Project Overview - Getting Started",
  "description": "A high-level tour of the JharkhandYatra Backend project structure and key files. Perfect for first-time explorers!",
  "steps": [
    {
      "file": "package.json",
      "line": 1,
      "title": "Welcome to JharkhandYatra Backend!",
      "description": "## Welcome to Your First Backend Project!\n\nThis is the **JharkhandYatra Backend API** - a server application that manages data for eco and cultural tourism in Jharkhand.\n\n### What is a Backend?\n\nThink of a website or mobile app as having two parts:\n- **Frontend** (what users see and click on - buttons, images, forms)\n- **Backend** (the hidden brain - stores data, processes requests, enforces rules)\n\nThis project IS the backend. When a tourist app shows homestays, the frontend asks THIS backend for the data.\n\n### What is an API?\n\n**API** stands for **Application Programming Interface**. It's like a waiter in a restaurant:\n- You (the frontend) tell the waiter (API) what you want\n- The waiter goes to the kitchen (database) and gets it\n- The waiter brings back your food (data)\n\n### Technologies You'll Learn:\n\n| Technology | What It Does | Analogy |\n|------------|--------------|--------|\n| **Express.js** | Handles web requests | The waiter taking orders |\n| **MongoDB** | Stores data | The kitchen's ingredient storage |\n| **Mongoose** | Talks to MongoDB easily | The recipe book |\n| **JWT** | Verifies user identity | The membership card |\n| **Zod** | Validates incoming data | The quality checker |\n| **Docker** | Runs MongoDB locally | A portable kitchen |\n\n**Don't worry if these seem overwhelming - we'll explain each one step by step!**"
    },
    {
      "file": "package.json",
      "line": 2,
      "title": "What is package.json?",
      "description": "## The Project's Identity Card\n\n`package.json` is the **most important configuration file** in any Node.js project. Think of it as the project's identity card and instruction manual combined.\n\n### Why do we need this file?\n\nImagine you're sharing this project with a friend. They need to know:\n- What is this project called?\n- What other software does it need to run?\n- How do they start it?\n\n`package.json` answers ALL these questions!\n\n### Key Parts:\n\n```json\n{\n  \"name\": \"sih-2025-jharkhand-tourism-backend\",  // Project name\n  \"version\": \"2.1.0\",                            // Current version\n  \"description\": \"...\",                          // What it does\n  \"main\": \"dist/server.js\",                      // Entry point file\n  \"scripts\": { ... },                            // Commands we can run\n  \"dependencies\": { ... },                       // Required packages\n  \"devDependencies\": { ... }                     // Development-only packages\n}\n```\n\n### What is Node.js?\n\n**Node.js** lets you run JavaScript code outside of a web browser. Normally, JavaScript only runs in browsers. Node.js allows us to use JavaScript to build server applications like this one.\n\n**NPM** (Node Package Manager) reads this file to know what to install."
    },
    {
      "file": "package.json",
      "line": 16,
      "title": "Dependencies - The Building Blocks",
      "description": "## Dependencies: Code Written by Others\n\nWhy write everything from scratch when brilliant developers have already solved common problems?\n\n**Dependencies** are pre-built code packages that we download and use in our project. This saves months of work!\n\n### Our Dependencies Explained:\n\n| Package | What It Does | Why We Need It |\n|---------|--------------|----------------|\n| `express` | Web server framework | Creates the server that listens for requests |\n| `mongoose` | MongoDB helper | Makes database operations simple and safe |\n| `bcrypt` | Password encryption | Scrambles passwords so hackers can't read them |\n| `jsonwebtoken` | Token generator | Creates secure \"passes\" that prove who you are |\n| `zod` | Data validator | Checks if incoming data is correct before using it |\n| `swagger-*` | Documentation | Auto-generates API docs for developers |\n| `tsx` | TypeScript runner | Runs TypeScript code directly without compiling |\n\n### Dependencies vs DevDependencies\n\n- **dependencies**: Needed to RUN the app (must be installed on the server)\n- **devDependencies**: Only needed while DEVELOPING (testing tools, TypeScript compiler)\n\n### What is TypeScript?\n\n**TypeScript** is JavaScript with extra safety features. It catches errors BEFORE you run the code, like a spell-checker for programmers.\n\nExample:\n```typescript\n// JavaScript: Might crash at runtime\nlet age = \"twenty\";  // Oops, should be a number!\nage = age + 1;       // \"twenty1\" - wrong!\n\n// TypeScript: Catches this mistake immediately\nlet age: number = \"twenty\";  // ERROR! String is not a number\n```"
    },
    {
      "file": "package.json",
      "line": 6,
      "title": "NPM Scripts - Shortcut Commands",
      "description": "## Scripts: Custom Commands for Your Project\n\nInstead of typing long commands, we create shortcuts called **scripts**.\n\n### Available Scripts:\n\n```bash\nnpm run dev       # Start the development server\nnpm run build     # Convert TypeScript to JavaScript\nnpm start         # Run the production server\nnpm run test:api  # Test the API endpoints\n```\n\n### Breaking Down the Dev Script:\n\n```json\n\"dev\": \"node --watch --env-file=.env --import=tsx src/server.ts\"\n```\n\nLet's decode this:\n- `node` - The program that runs JavaScript\n- `--watch` - Automatically restart when files change (hot reload)\n- `--env-file=.env` - Load secret configuration from .env file\n- `--import=tsx` - Enable TypeScript support\n- `src/server.ts` - The file to run\n\n### Why \"npm run\" instead of just the command?\n\nNPM scripts can:\n1. Be remembered easily (just run `npm run dev`)\n2. Work the same way on every computer\n3. Be combined with other scripts\n\n### What is Hot Reload?\n\nWithout hot reload, you'd have to:\n1. Stop the server\n2. Run it again\n3. Test your changes\n\nWith hot reload (--watch), Node.js automatically restarts when you save a file. This saves SO much time during development!"
    },
    {
      "file": "src/server.ts",
      "line": 1,
      "title": "The Heart of the Application",
      "description": "## server.ts: Where Everything Begins\n\nWhen you run `npm run dev`, THIS is the file that executes. It's like the main() function in C or Java.\n\n### What is a .ts file?\n\nFiles ending in `.ts` are **TypeScript** files. They look like JavaScript but with type annotations:\n\n```typescript\n// JavaScript\nfunction greet(name) {\n  return \"Hello \" + name;\n}\n\n// TypeScript\nfunction greet(name: string): string {\n  return \"Hello \" + name;\n}\n```\n\nThe `: string` tells TypeScript that `name` must be text and the function returns text.\n\n### What This File Does (in order):\n\n1. **Imports** - Brings in code from other files and packages\n2. **Creates Express app** - Sets up the web server\n3. **Configures middleware** - Adds processing layers\n4. **Registers routes** - Defines what URLs are available\n5. **Connects to database** - Establishes MongoDB connection\n6. **Starts listening** - Opens the server for business\n\n### What is Express?\n\n**Express.js** is a web framework for Node.js. Without it, you'd write hundreds of lines of code just to handle a simple web request. Express does the heavy lifting.\n\nThink of it like this:\n- Without Express: Building a car from raw metal\n- With Express: Buying a car and customizing it"
    },
    {
      "file": "src/config/database.ts",
      "line": 1,
      "title": "Database Configuration",
      "description": "## Connecting to MongoDB\n\n### What is a Database?\n\nA **database** is organized storage for your application's data. Without it, all data would be lost when the server restarts!\n\nTypes of databases:\n- **SQL databases** (MySQL, PostgreSQL): Data in tables with rows and columns\n- **NoSQL databases** (MongoDB): Data in flexible documents (like JSON)\n\n### Why MongoDB?\n\nMongoDB stores data as **documents** that look like JavaScript objects:\n\n```javascript\n{\n  \"_id\": \"abc123\",\n  \"name\": \"Sunset Homestay\",\n  \"location\": {\n    \"district\": \"Ranchi\",\n    \"state\": \"Jharkhand\"\n  },\n  \"price\": 1500,\n  \"amenities\": [\"WiFi\", \"Breakfast\", \"Parking\"]\n}\n```\n\nThis flexibility is perfect for real-world data that doesn't fit neatly into tables.\n\n### What is Mongoose?\n\n**Mongoose** is an **ODM (Object Document Mapper)**. It's a translator between your JavaScript code and MongoDB.\n\nWithout Mongoose:\n```javascript\ndb.collection('users').insertOne({ name: 'John', email: 'john@example.com' });\n```\n\nWith Mongoose:\n```javascript\nconst user = new User({ name: 'John', email: 'john@example.com' });\nawait user.save();\n```\n\nMongoose also validates data, provides helpful methods, and catches errors early."
    },
    {
      "file": "src/routes/index.ts",
      "line": 1,
      "title": "Route Organization",
      "description": "## Routes: The API Menu\n\nThink of routes as items on a restaurant menu. Each route is a specific action the API can perform.\n\n### What is Routing?\n\nWhen you visit a website like `google.com/search?q=cats`, the server needs to know:\n- **What URL** was requested? (`/search`)\n- **What method** was used? (GET, POST, PUT, DELETE)\n- **What to do** with this request? (search for cats)\n\n**Routing** is matching URLs to the code that handles them.\n\n### Our API Routes:\n\n| URL | Purpose | Example |\n|-----|---------|--------|\n| `/api/v1/auth` | User login/register | Sign in to account |\n| `/api/v1/homestays` | Accommodation listings | Browse places to stay |\n| `/api/v1/guides` | Tour guide profiles | Find a local guide |\n| `/api/v1/products` | Local handicrafts | Buy souvenirs |\n| `/api/v1/bookings` | Reservations | Book a homestay |\n| `/api/v1/search` | Search everything | Find items by keyword |\n\n### Why /api/v1?\n\nThe `/api` prefix separates API routes from potential web pages.\n\nThe `/v1` is **API versioning**. If we make breaking changes later, we create `/v2` instead of breaking existing apps that use `/v1`.\n\n### Why Organize Routes in Separate Files?\n\nImagine putting ALL routes in one file - it would be thousands of lines! Separating by feature (auth, homestays, etc.) makes code:\n- Easier to find\n- Easier to maintain\n- Easier for teams to work on different parts"
    },
    {
      "file": "src/models/users/User.model.ts",
      "line": 1,
      "title": "Data Models",
      "description": "## Models: Blueprints for Your Data\n\n### What is a Model?\n\nA **model** defines the SHAPE of your data - what fields it has, what types they are, and what rules they follow.\n\nReal-world analogy: A model is like a form you fill out. The form has specific fields (Name, Email, Phone) and rules (Phone must be 10 digits).\n\n### Our Models:\n\n| Model | What It Represents | Key Fields |\n|-------|-------------------|------------|\n| **User** | App users | email, password, name, role |\n| **Homestay** | Places to stay | title, location, price, amenities |\n| **Guide** | Tour guides | name, languages, expertise |\n| **Product** | Handicrafts | name, price, category, stock |\n| **Booking** | Reservations | userId, resourceId, dates, status |\n\n### Why Define Models?\n\nWithout models, anyone could store anything:\n```javascript\n// Bad: No rules!\ndb.users.insert({ naem: 'John', emial: 'test' });  // Typos allowed!\n```\n\nWith models:\n```javascript\n// Good: Enforced structure\nconst user = new User({ name: 'John', email: 'invalid' });\nawait user.save();  // ERROR: Invalid email format!\n```\n\n### Schema vs Model\n\n- **Schema**: The blueprint (what fields, what rules)\n- **Model**: The factory that creates documents from the blueprint\n\nSchema is the architectural drawing. Model is the construction company."
    },
    {
      "file": "src/controllers/auth.controller.ts",
      "line": 1,
      "title": "Controllers - Business Logic",
      "description": "## Controllers: The Brain of Your API\n\n### What is a Controller?\n\nA **controller** contains the logic that handles requests. It's the brain that decides what to do.\n\n### Request Flow:\n\n```\nUser clicks \"Login\"\n    ↓\nRequest: POST /api/v1/auth/login\n    ↓\nRoute matches → calls login controller\n    ↓\nController:\n  1. Gets email/password from request\n  2. Finds user in database\n  3. Checks if password matches\n  4. Creates login token\n  5. Sends response\n    ↓\nUser receives: { success: true, token: \"...\" }\n```\n\n### Why Separate Controllers from Routes?\n\nRoutes should be SHORT - just connecting URLs to handlers.\nControllers handle the LOGIC - database queries, calculations, decisions.\n\n```javascript\n// Route file (short and clear)\nrouter.post('/login', validate(loginSchema), login);\n\n// Controller file (contains the actual logic)\nexport async function login(req, res) {\n  // 20+ lines of logic here\n}\n```\n\n### Controller Responsibilities:\n\n1. **Extract data** from the request\n2. **Validate business rules** (not just data format)\n3. **Call the database** through models\n4. **Format the response** and send it back\n\nControllers should NOT:\n- Know about HTTP headers directly (use middleware)\n- Contain database schema definitions (use models)\n- Handle request parsing (Express does this)"
    },
    {
      "file": "src/middleware/auth.middleware.ts",
      "line": 1,
      "title": "Middleware - Request Processing Layers",
      "description": "## Middleware: The Security Checkpoints\n\n### What is Middleware?\n\n**Middleware** are functions that run BETWEEN receiving a request and sending a response. They're like security checkpoints at an airport.\n\n```\nRequest arrives\n    ↓\n[Middleware 1: Parse JSON body]\n    ↓\n[Middleware 2: Check authentication]\n    ↓\n[Middleware 3: Check permissions]\n    ↓\n[Middleware 4: Validate data]\n    ↓\nController handles request\n    ↓\nResponse sent\n```\n\n### Our Middleware:\n\n| Middleware | What It Checks | What Happens If Failed |\n|------------|----------------|----------------------|\n| `express.json()` | Is the body valid JSON? | Returns 400 Bad Request |\n| `authenticate` | Is user logged in? | Returns 401 Unauthorized |\n| `requireRole` | Does user have the right role? | Returns 403 Forbidden |\n| `validate` | Is the data format correct? | Returns 400 with error details |\n\n### Why Use Middleware?\n\nWithout middleware, EVERY controller would need:\n```javascript\nfunction createHomestay(req, res) {\n  // Check if logged in... (5 lines)\n  // Check if they're a host... (5 lines)\n  // Validate the data... (10 lines)\n  // FINALLY do the actual work\n}\n```\n\nWith middleware:\n```javascript\nrouter.post('/', authenticate, requireRole('host'), validate(schema), createHomestay);\n\nfunction createHomestay(req, res) {\n  // Just do the actual work - checks already passed!\n}\n```\n\nMiddleware keeps your code **DRY** (Don't Repeat Yourself)."
    },
    {
      "file": "src/validation/index.ts",
      "line": 1,
      "title": "Validation - Checking User Input",
      "description": "## Validation: Never Trust User Input!\n\n### Why Validate?\n\nUsers (and hackers) can send ANYTHING to your API:\n- Missing fields\n- Wrong data types (text instead of numbers)\n- Malicious code (SQL injection, script attacks)\n- Invalid formats (bad emails, short passwords)\n\n**Golden Rule**: Never trust input. Always validate.\n\n### What is Zod?\n\n**Zod** is a validation library that lets you define rules for your data:\n\n```typescript\nconst userSchema = z.object({\n  email: z.string().email(),           // Must be valid email\n  password: z.string().min(8),          // At least 8 characters\n  age: z.number().min(18).optional(),   // Optional, but if present, must be 18+\n});\n```\n\n### Validation in Action:\n\n```javascript\n// User sends: { email: \"bad\", password: \"123\" }\n\n// Zod checks and responds:\n{\n  \"success\": false,\n  \"errors\": [\n    { \"field\": \"email\", \"message\": \"Invalid email format\" },\n    { \"field\": \"password\", \"message\": \"Must be at least 8 characters\" }\n  ]\n}\n```\n\n### Validation vs Authentication vs Authorization\n\n| Term | Question It Answers | Example |\n|------|---------------------|--------|\n| **Validation** | Is the data correct? | Is this a valid email? |\n| **Authentication** | Who are you? | Are you logged in? |\n| **Authorization** | What can you do? | Can you delete this? |"
    },
    {
      "file": "src/utils/response.utils.ts",
      "line": 1,
      "title": "Utility Functions",
      "description": "## Utilities: Helper Functions for Consistency\n\n### Why Utility Functions?\n\nWithout utilities, responses might look different everywhere:\n```javascript\n// Controller 1\nres.json({ success: true, data: user });\n\n// Controller 2\nres.json({ ok: true, result: user });\n\n// Controller 3\nres.json({ status: 'success', user: user });\n```\n\nThis inconsistency makes the API confusing to use!\n\n### Our Response Utilities:\n\n```typescript\n// Always use these for consistency\nsendSuccess(res, data, 200, 'User created!');\nsendError(res, 'Not found', 404);\n```\n\n### Standard Response Format:\n\n**Success:**\n```json\n{\n  \"success\": true,\n  \"data\": { \"id\": \"123\", \"name\": \"John\" },\n  \"message\": \"User created successfully\"\n}\n```\n\n**Error:**\n```json\n{\n  \"success\": false,\n  \"message\": \"User not found\"\n}\n```\n\n### HTTP Status Codes (The Important Ones):\n\n| Code | Meaning | When To Use |\n|------|---------|-------------|\n| 200 | OK | Request succeeded |\n| 201 | Created | New resource created |\n| 400 | Bad Request | Invalid input data |\n| 401 | Unauthorized | Not logged in |\n| 403 | Forbidden | Logged in but not allowed |\n| 404 | Not Found | Resource doesn't exist |\n| 500 | Server Error | Something broke on our end |"
    },
    {
      "file": ".env.example",
      "line": 1,
      "title": "Environment Variables",
      "description": "## Environment Variables: Keeping Secrets Safe\n\n### The Problem\n\nYour code needs sensitive information:\n- Database passwords\n- Secret keys\n- API credentials\n\nIf you put these in your code and push to GitHub, HACKERS CAN SEE THEM!\n\n### The Solution: Environment Variables\n\n**Environment variables** are settings stored OUTSIDE your code:\n\n```bash\n# .env file (NEVER commit this!)\nPORT=5000\nMONGO_URI=mongodb://username:password@localhost:27017/mydb\nJWT_SECRET=my-super-secret-key-nobody-can-guess\n```\n\nYour code reads these:\n```typescript\nconst port = process.env.PORT;  // Gets \"5000\"\nconst secret = process.env.JWT_SECRET;  // Gets the secret key\n```\n\n### .env vs .env.example\n\n| File | Contains | Commit to Git? |\n|------|----------|---------------|\n| `.env` | REAL secrets | **NEVER!** |\n| `.env.example` | Fake/sample values | Yes |\n\n`.env.example` shows teammates what variables they need without revealing actual secrets.\n\n### How Secrets Are Kept Safe:\n\n1. `.env` is in `.gitignore` (Git ignores it)\n2. Each developer creates their own `.env` from `.env.example`\n3. Production servers have their own secure environment variables\n\n---\n\n## Tour Complete!\n\nYou now understand the project structure! Continue with Tour 02 to dive into the Express server setup."
    }
  ]
}
