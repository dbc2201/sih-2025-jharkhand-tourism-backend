{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "07. Complete Request Flow",
  "description": "Follow a request from arrival to response - see how all the pieces fit together!",
  "steps": [
    {
      "file": "src/server.ts",
      "line": 56,
      "title": "The Big Picture",
      "description": "## Following a Request Through the System\n\nIn previous tours, we learned about individual components:\n- Express server setup\n- MongoDB and models\n- Authentication middleware\n- Authorization (RBAC)\n- Validation with Zod\n\nNow let's see how they all work TOGETHER!\n\n### Our Example Request:\n\n```http\nPOST /api/v1/auth/register HTTP/1.1\nContent-Type: application/json\n\n{\n  \"email\": \"student@example.com\",\n  \"password\": \"securePass123\",\n  \"name\": \"Test Student\"\n}\n```\n\n### What Happens (High Level):\n\n```\n1. Browser sends HTTP request\n2. Express receives it\n3. Middleware processes it (JSON parsing, validation, etc.)\n4. Route matches and controller runs\n5. Database operation happens\n6. Response is sent back\n7. Browser receives response\n```\n\n### Why This Matters:\n\nUnderstanding request flow helps you:\n- Debug problems (where did it fail?)\n- Add new features (where should this code go?)\n- Optimize performance (what's slow?)"
    },
    {
      "file": "src/server.ts",
      "line": 56,
      "title": "Step 1: Request Arrives",
      "description": "## The Journey Begins\n\n### What Happens When You Make a Request:\n\n```\nYour Browser → Internet → Server's Port 5000 → Express\n```\n\n**Node.js is listening on port 5000.** When a request arrives, Express takes over.\n\n### Express Receives:\n\n```\nPOST /api/v1/auth/register HTTP/1.1\nHost: localhost:5000\nContent-Type: application/json\n\n{\"email\":\"student@example.com\",\"password\":\"securePass123\",\"name\":\"Test Student\"}\n```\n\n### Express Creates Request Object:\n\n```javascript\nreq = {\n  method: 'POST',\n  url: '/api/v1/auth/register',\n  headers: {\n    'content-type': 'application/json',\n    'host': 'localhost:5000'\n  },\n  body: <raw bytes>,  // Not parsed yet!\n  params: {},\n  query: {}\n}\n```\n\n### The First Match:\n\n```typescript\napp.use('/api/v1', apiRouter);\n```\n\nExpress sees the path starts with `/api/v1`, so it:\n1. Strips `/api/v1` from the path\n2. Forwards to `apiRouter`\n3. Remaining path: `/auth/register`"
    },
    {
      "file": "src/routes/index.ts",
      "line": 1,
      "title": "Step 2: Route Aggregation",
      "description": "## The Central Route Registry\n\n### Inside apiRouter:\n\n```typescript\nconst router = express.Router();\n\nrouter.use('/auth', authRoutes);\nrouter.use('/homestays', homestayRoutes);\nrouter.use('/guides', guideRoutes);\nrouter.use('/products', productRoutes);\nrouter.use('/bookings', bookingRoutes);\nrouter.use('/search', searchRoutes);\n\nexport default router;\n```\n\n### What Happens:\n\nRemaining path is `/auth/register`.\n\nExpress checks each `router.use()` in order:\n- `/auth` - MATCH!\n\nNow it:\n1. Strips `/auth` from the path\n2. Forwards to `authRoutes`\n3. Remaining path: `/register`\n\n### Why This Two-Level Routing?\n\n**Organization!** Each feature has its own route file:\n\n```\n/api/v1\n  ├── /auth         → Auth.route.ts\n  ├── /homestays    → Homestays.route.ts\n  ├── /guides       → Guides.route.ts\n  └── ...\n```\n\nThis keeps code manageable as the project grows."
    },
    {
      "file": "src/routes/auth/Auth.route.ts",
      "line": 36,
      "title": "Step 3: Route Matching",
      "description": "## Finding the Right Handler\n\n### Inside Auth.route.ts:\n\n```typescript\nconst router = express.Router();\n\nrouter.post('/register', validate(registerSchema), register);\nrouter.post('/login', validate(loginSchema), login);\nrouter.get('/me', authenticate, getProfile);\n// ...\n```\n\n### The Match:\n\n```\nMethod: POST\nPath: /register\n→ Matches: router.post('/register', ...)\n```\n\n### The Middleware Chain:\n\n```typescript\nrouter.post('/register', validate(registerSchema), register);\n//                       └────────────┬───────────┘  └──┬──┘\n//                           Middleware             Controller\n```\n\nExpress will run these in order:\n1. `validate(registerSchema)` - Check the data\n2. `register` - Handle the request (if validation passes)\n\n### What is a Middleware Chain?\n\nIt's like an assembly line:\n\n```\nRequest → [Parser] → [Validator] → [Authenticator] → [Controller] → Response\n```\n\nEach step can:\n- Modify the request\n- Send a response (and stop the chain)\n- Pass control to the next step (`next()`)"
    },
    {
      "file": "src/middleware/validation.middleware.ts",
      "line": 15,
      "title": "Step 4: Validation",
      "description": "## Checking the Request Data\n\n### The validate() Middleware:\n\n```typescript\nfunction validate(schema) {\n  return (req, res, next) => {\n    // Parse and validate\n    const result = schema.safeParse({\n      body: req.body,\n      query: req.query,\n      params: req.params\n    });\n    \n    if (!result.success) {\n      // Validation failed!\n      return sendError(res, 'Validation failed', 400, errors);\n    }\n    \n    // Validation passed - use the cleaned data\n    req.body = result.data.body;\n    next();  // Continue to controller\n  };\n}\n```\n\n### For Our Request:\n\n```javascript\n// Input\n{\n  email: \"student@example.com\",\n  password: \"securePass123\",\n  name: \"Test Student\"\n}\n\n// Validation checks:\n✓ email is a string with valid email format\n✓ password is a string with 8+ characters\n✓ name is a string with 1-100 characters\n✓ role is missing, so default to 'customer'\n\n// Output (with default applied)\n{\n  email: \"student@example.com\",\n  password: \"securePass123\",\n  name: \"Test Student\",\n  role: \"customer\"  // Added by Zod!\n}\n```\n\n### If Validation Failed:\n\nChain stops here, 400 error sent back, controller never runs."
    },
    {
      "file": "src/controllers/auth.controller.ts",
      "line": 100,
      "title": "Step 5: Controller Execution",
      "description": "## The Business Logic\n\nValidation passed! Now the `register` controller runs:\n\n```typescript\nexport async function register(req: Request, res: Response) {\n  // 1. Extract validated data\n  const { email, password, name, role } = req.body;\n  \n  // 2. Check for existing user\n  const existingUser = await UserModel.findOne({ email });\n  if (existingUser) {\n    return sendError(res, 'Email already registered', 409);\n  }\n  \n  // 3. Create new user\n  const user = new UserModel({ email, password, name, role });\n  await user.save();  // ← Triggers pre-save hook!\n  \n  // 4. Generate JWT token\n  const token = generateToken(user._id, user.role);\n  \n  // 5. Send response\n  sendSuccess(res, { user: toUserResponse(user), token }, 201);\n}\n```\n\n### Step-by-Step Breakdown:\n\n**Step 1:** Data is already validated, just extract it.\n\n**Step 2:** Query MongoDB - is this email taken?\n\n**Step 3:** Create user document. Note: `user.save()` triggers our pre-save hook (password hashing)!\n\n**Step 4:** Create JWT so user is \"logged in\" immediately.\n\n**Step 5:** Send success response with user data and token."
    },
    {
      "file": "src/models/users/User.model.ts",
      "line": 96,
      "title": "Step 6: Pre-Save Hook",
      "description": "## Automatic Password Hashing\n\nWhen `user.save()` is called, this hook runs FIRST:\n\n```typescript\nuserSchema.pre('save', async function () {\n  // Only hash if password was modified\n  if (!this.isModified('password')) return;\n  \n  // Generate salt and hash\n  const salt = await bcrypt.genSalt(12);\n  this.password = await bcrypt.hash(this.password, salt);\n});\n```\n\n### Before and After:\n\n```javascript\n// Before pre-save hook\nuser.password = \"securePass123\"\n\n// After pre-save hook  \nuser.password = \"$2b$12$K9GpZpYP.wCq8nL6vM5x...\"\n```\n\n### Why Hooks Are Powerful:\n\nThe controller doesn't need to know about password hashing!\n\n```javascript\n// Controller just does this:\nconst user = new UserModel({ email, password, name });\nawait user.save();\n// Password is automatically hashed!\n```\n\n**Separation of concerns:** \n- Controller: Handles HTTP request/response\n- Model hook: Handles data transformation\n\n### After the Hook:\n\nMongoose sends the INSERT command to MongoDB. The user is now saved!"
    },
    {
      "file": "src/middleware/auth.middleware.ts",
      "line": 115,
      "title": "Step 7: Token Generation",
      "description": "## Creating the JWT\n\n```typescript\nconst token = generateToken(user._id, user.role);\n```\n\n### Inside generateToken:\n\n```typescript\nfunction generateToken(userId, role) {\n  return jwt.sign(\n    { userId, role },           // What to encode\n    process.env.JWT_SECRET,     // Secret key\n    { expiresIn: '7d' }         // Expires in 7 days\n  );\n}\n```\n\n### What Gets Created:\n\n```\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.\neyJ1c2VySWQiOiI1MDdmMWY3N2JjZjg2Y2Q3OTk0MzkwMTEiLCJyb2xlIjoiY3VzdG9tZXIiLCJpYXQiOjE3MDMwMDAwMDB9.\nXXX_signature_XXX\n```\n\n### Decoded Payload:\n\n```json\n{\n  \"userId\": \"507f1f77bcf86cd799439011\",\n  \"role\": \"customer\",\n  \"iat\": 1703000000,  // Issued at\n  \"exp\": 1703604800   // Expires at\n}\n```\n\n### Why Include role?\n\nSo we don't need a database lookup every time we check permissions!\n\nThe token CONTAINS the role - just decode and check."
    },
    {
      "file": "src/utils/response.utils.ts",
      "line": 1,
      "title": "Step 8: Sending the Response",
      "description": "## Formatting and Sending\n\n```typescript\nsendSuccess(res, { user: toUserResponse(user), token }, 201);\n```\n\n### Inside sendSuccess:\n\n```typescript\nfunction sendSuccess(res, data, statusCode = 200, message?) {\n  res.status(statusCode).json({\n    success: true,\n    data,\n    ...(message && { message })\n  });\n}\n```\n\n### The Transformation:\n\n**toUserResponse() removes sensitive data:**\n```javascript\n// Raw Mongoose document\n{\n  _id: ObjectId(\"507f1f77...\"),\n  email: \"student@example.com\",\n  password: \"$2b$12$K9GpZp...\",  // DANGER!\n  name: \"Test Student\",\n  role: \"customer\",\n  __v: 0  // Internal field\n}\n\n// After toUserResponse()\n{\n  id: \"507f1f77...\",\n  email: \"student@example.com\",\n  name: \"Test Student\",\n  role: \"customer\"\n}\n```\n\n### Final HTTP Response:\n\n```http\nHTTP/1.1 201 Created\nContent-Type: application/json\n\n{\n  \"success\": true,\n  \"data\": {\n    \"user\": {\n      \"id\": \"507f1f77bcf86cd799439011\",\n      \"email\": \"student@example.com\",\n      \"name\": \"Test Student\",\n      \"role\": \"customer\"\n    },\n    \"token\": \"eyJhbGciOiJIUzI1NiIs...\"\n  }\n}\n```"
    },
    {
      "file": "src/server.ts",
      "line": 1,
      "title": "The Complete Journey",
      "description": "## Full Request Flow Diagram\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                    REQUEST FLOW                         │\n├─────────────────────────────────────────────────────────┤\n│                                                         │\n│  Browser sends POST /api/v1/auth/register               │\n│           ↓                                             │\n│  [Node.js receives on port 5000]                        │\n│           ↓                                             │\n│  [express.json() parses body]                           │\n│           ↓                                             │\n│  [app.use('/api/v1', apiRouter)]                        │\n│           ↓                                             │\n│  [router.use('/auth', authRoutes)]                      │\n│           ↓                                             │\n│  [router.post('/register', validate, register)]         │\n│           ↓                                             │\n│  [validate(registerSchema)] ← Checks data               │\n│           ↓ (passes)                                    │\n│  [register controller]                                  │\n│     ├── Check if email exists                           │\n│     ├── Create user document                            │\n│     ├── [pre-save hook hashes password]                 │\n│     ├── Save to MongoDB                                 │\n│     ├── Generate JWT token                              │\n│     └── Send success response                           │\n│           ↓                                             │\n│  Browser receives: { success: true, data: {...} }       │\n│                                                         │\n└─────────────────────────────────────────────────────────┘\n```\n\n### Key Takeaways:\n\n1. **Layered Architecture** - Each layer has one job\n2. **Middleware Chain** - Process request step by step\n3. **Fail Fast** - Validation happens early\n4. **Separation of Concerns** - Controllers don't know about hashing\n5. **Consistent Responses** - Same format every time\n\n---\n\n## Tour Complete!\n\nYou've traced a request through the entire stack! Continue with Tour 08 to learn about Docker for local development."
    }
  ]
}
