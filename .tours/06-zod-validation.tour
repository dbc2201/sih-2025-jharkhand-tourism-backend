{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "06. Request Validation with Zod",
  "description": "Learn how Zod schemas validate incoming request data.",
  "steps": [
    {
      "file": "src/validation/index.ts",
      "line": 1,
      "title": "Why Validate User Input?",
      "description": "## The Danger of Trusting User Input\n\n### The Golden Rule of Web Development:\n\n**NEVER trust data from users!**\n\nUsers can send ANYTHING to your API - whether by accident or maliciously.\n\n### Examples of Bad Input:\n\n**Missing fields:**\n```json\n{ \"email\": \"test@example.com\" }  // Where's the password?\n```\n\n**Wrong types:**\n```json\n{ \"price\": \"expensive\" }  // Should be a number!\n```\n\n**Invalid formats:**\n```json\n{ \"email\": \"not-an-email\" }  // No @ symbol\n```\n\n**Malicious input:**\n```json\n{ \"email\": \"<script>stealData()</script>\" }  // XSS attack!\n```\n\n### What Happens Without Validation:\n\n```javascript\nconst price = req.body.price;  // \"expensive\"\nconst total = price * 2;       // NaN - Not a Number!\nawait order.save();            // Saved garbage to database!\n```\n\n### What is Validation?\n\n**Validation** is checking that data:\n- Exists (not missing)\n- Has the right type (string, number, etc.)\n- Follows rules (format, length, range)\n- Is safe (no malicious content)\n\n**Validate BEFORE processing!**"
    },
    {
      "file": "src/validation/index.ts",
      "line": 1,
      "title": "What is Zod?",
      "description": "## Introducing Zod\n\n### What is Zod?\n\n**Zod** is a TypeScript-first schema validation library. It lets you:\n1. Define the expected shape of data\n2. Validate incoming data against that shape\n3. Get TypeScript types automatically\n\n### Why Zod Over Other Options?\n\n| Feature | Zod | Other Libraries |\n|---------|-----|-----------------|\n| TypeScript-first | Native | Often bolted on |\n| Zero dependencies | Yes | Usually have many |\n| Type inference | Automatic | Manual types needed |\n| Error messages | Excellent | Often cryptic |\n| Bundle size | Small | Often large |\n\n### Basic Zod Example:\n\n```typescript\nimport { z } from 'zod';\n\n// Define the schema (what we expect)\nconst userSchema = z.object({\n  name: z.string(),\n  age: z.number()\n});\n\n// Validate data\nconst result = userSchema.safeParse({ name: 'John', age: 25 });\n\nif (result.success) {\n  console.log(result.data);  // { name: 'John', age: 25 }\n} else {\n  console.log(result.error);  // Validation errors\n}\n```\n\n### The Power of Zod:\n\n```typescript\n// Define once\nconst schema = z.object({ name: z.string() });\n\n// Get TypeScript type automatically!\ntype User = z.infer<typeof schema>;\n// User = { name: string }\n```\n\n**Single source of truth** - No duplicate type definitions!"
    },
    {
      "file": "src/validation/schemas/auth.schema.ts",
      "line": 10,
      "title": "Registration Validation Schema",
      "description": "## Validating User Registration\n\n```typescript\nexport const registerSchema = z.object({\n  body: z.object({\n    email: z.string()\n      .email('Invalid email format'),\n    \n    password: z.string()\n      .min(8, 'Password must be at least 8 characters'),\n    \n    name: z.string()\n      .min(1, 'Name is required')\n      .max(100, 'Name too long'),\n    \n    role: z.enum(['admin', 'host', 'guide', 'customer'])\n      .optional()\n      .default('customer')\n  })\n});\n```\n\n### Breaking Down Each Field:\n\n**email:**\n```typescript\nz.string()                    // Must be a string\n  .email('Invalid email')     // Must be valid email format\n```\n\n**password:**\n```typescript\nz.string()                           // Must be a string\n  .min(8, 'At least 8 characters')   // Minimum 8 characters\n```\n\n**name:**\n```typescript\nz.string()                    // Must be a string\n  .min(1, 'Required')         // Can't be empty\n  .max(100, 'Too long')       // Maximum 100 characters\n```\n\n**role:**\n```typescript\nz.enum(['admin', 'host', 'guide', 'customer'])  // Must be one of these\n  .optional()                                     // Not required\n  .default('customer')                            // Defaults to 'customer'\n```\n\n### Why Wrap in `body`?\n\nThe schema validates the ENTIRE request, not just the body. This allows validating query params and URL params too!"
    },
    {
      "file": "src/validation/schemas/auth.schema.ts",
      "line": 30,
      "title": "Login Validation Schema",
      "description": "## Simpler Schema for Login\n\n```typescript\nexport const loginSchema = z.object({\n  body: z.object({\n    email: z.string()\n      .email('Invalid email'),\n    \n    password: z.string()\n      .min(1, 'Password is required')\n  })\n});\n```\n\n### Why Simpler Than Registration?\n\nFor login, we only need to check:\n- Email exists and is valid format\n- Password exists (any length)\n\nWe DON'T check password length because:\n1. The real check is against the database\n2. Revealing \"too short\" hints at our password requirements\n3. Old users might have passwords from before rule changes\n\n### Security Consideration:\n\nDon't give attackers free information!\n\n**Bad:**\n```\n\"Email must be valid\" → They now know email format\n\"Password must be 8+ chars\" → They know our minimum\n```\n\n**Good:**\n```\n\"Invalid credentials\" → Same message for all failures\n```\n\nLogin validation should be minimal - just ensure fields exist."
    },
    {
      "file": "src/validation/schemas/auth.schema.ts",
      "line": 45,
      "title": "Type Inference from Schemas",
      "description": "## Getting TypeScript Types Automatically\n\n```typescript\nexport type RegisterDTO = z.infer<typeof registerSchema>['body'];\nexport type LoginDTO = z.infer<typeof loginSchema>['body'];\n```\n\n### What This Does:\n\n**Step 1: Infer the full type**\n```typescript\nz.infer<typeof registerSchema>\n// Results in:\n// {\n//   body: {\n//     email: string;\n//     password: string;\n//     name: string;\n//     role?: 'admin' | 'host' | 'guide' | 'customer';\n//   }\n// }\n```\n\n**Step 2: Extract just the body**\n```typescript\nz.infer<typeof registerSchema>['body']\n// Results in:\n// {\n//   email: string;\n//   password: string;\n//   name: string;\n//   role?: 'admin' | 'host' | 'guide' | 'customer';\n// }\n```\n\n### What is a DTO?\n\n**DTO** = Data Transfer Object\n\nIt's a type that represents data moving between layers (from client to server, or server to database).\n\n### Why This is Powerful:\n\n```typescript\n// In controller:\nfunction register(req: Request, res: Response) {\n  const data: RegisterDTO = req.body;  // TypeScript knows the shape!\n  console.log(data.email);             // Autocomplete works!\n  console.log(data.unknown);           // ERROR: Property doesn't exist!\n}\n```\n\n**No duplicate types needed!**"
    },
    {
      "file": "src/middleware/validation.middleware.ts",
      "line": 1,
      "title": "The Validation Middleware",
      "description": "## How Validation Works as Middleware\n\n```typescript\nimport { z } from 'zod';\nimport { Request, Response, NextFunction } from 'express';\n\nexport function validate(schema: z.ZodSchema) {\n  return (req: Request, res: Response, next: NextFunction) => {\n    const result = schema.safeParse({\n      body: req.body,\n      query: req.query,\n      params: req.params\n    });\n    \n    if (!result.success) {\n      // Validation failed - send error response\n      const errors = result.error.errors.map(err => ({\n        field: err.path.join('.'),\n        message: err.message\n      }));\n      \n      return sendError(res, 'Validation failed', 400, errors);\n    }\n    \n    // Validation passed - use parsed/transformed data\n    req.body = result.data.body;\n    req.query = result.data.query;\n    req.params = result.data.params;\n    \n    next();  // Continue to controller\n  };\n}\n```\n\n### How It Works:\n\n**Step 1: safeParse()**\n```typescript\nschema.safeParse(data)\n// Returns: { success: true, data: {...} }\n// Or:      { success: false, error: ZodError }\n```\n\n**Step 2: Handle Failure**\nReturn 400 Bad Request with detailed error messages.\n\n**Step 3: Handle Success**\nReplace `req.body` with parsed data (includes defaults, transforms).\n\n**Step 4: Continue**\n`next()` passes control to the next middleware or controller."
    },
    {
      "file": "src/middleware/validation.middleware.ts",
      "line": 20,
      "title": "Error Response Format",
      "description": "## Making Errors Helpful\n\n### What Zod Errors Look Like:\n\n```typescript\n{\n  \"issues\": [\n    {\n      \"code\": \"invalid_string\",\n      \"validation\": \"email\",\n      \"message\": \"Invalid email format\",\n      \"path\": [\"body\", \"email\"]\n    },\n    {\n      \"code\": \"too_small\",\n      \"minimum\": 8,\n      \"type\": \"string\",\n      \"message\": \"Password must be at least 8 characters\",\n      \"path\": [\"body\", \"password\"]\n    }\n  ]\n}\n```\n\n### How We Transform Them:\n\n```typescript\nconst errors = result.error.errors.map(err => ({\n  field: err.path.join('.'),   // ['body', 'email'] → 'body.email'\n  message: err.message          // Human-readable message\n}));\n```\n\n### Resulting API Response:\n\n```json\n{\n  \"success\": false,\n  \"message\": \"Validation failed\",\n  \"errors\": [\n    { \"field\": \"body.email\", \"message\": \"Invalid email format\" },\n    { \"field\": \"body.password\", \"message\": \"Password must be at least 8 characters\" }\n  ]\n}\n```\n\n### Why This Format?\n\n1. **Clear field names** - Frontend knows which input has the error\n2. **Human-readable messages** - Can show directly to users\n3. **Multiple errors** - Fix all issues at once, not one by one\n4. **Consistent structure** - Same format for all validation errors"
    },
    {
      "file": "src/validation/schemas/common.schema.ts",
      "line": 1,
      "title": "Reusable Schema Components",
      "description": "## DRY: Don't Repeat Yourself\n\n### Common Patterns Used Everywhere:\n\n**MongoDB ObjectId:**\n```typescript\nexport const objectIdSchema = z.string()\n  .regex(/^[a-fA-F0-9]{24}$/, 'Invalid ID format');\n```\n\nMongoDB IDs are 24 hexadecimal characters. This validates that format.\n\n**Pagination:**\n```typescript\nexport const paginationSchema = z.object({\n  page: z.coerce.number().min(1).default(1),\n  limit: z.coerce.number().min(1).max(100).default(10)\n});\n```\n\n**What is `z.coerce`?**\n\nQuery parameters come as strings! `z.coerce.number()` converts:\n```javascript\n\"5\" → 5\n\"abc\" → Error\n```\n\n**ID in URL params:**\n```typescript\nexport const idParamSchema = z.object({\n  params: z.object({\n    id: objectIdSchema\n  })\n});\n```\n\n### Why Create Reusable Schemas?\n\nWithout reuse:\n```typescript\n// File 1\nz.string().regex(/^[a-fA-F0-9]{24}$/, 'Invalid ID');\n// File 2\nz.string().regex(/^[a-fA-F0-9]{24}$/, 'Invalid ID');\n// File 3... (repeat everywhere)\n```\n\nWith reuse:\n```typescript\n// Define once\nexport const objectIdSchema = z.string().regex(...);\n\n// Use everywhere\nimport { objectIdSchema } from './common';\n```\n\n**One change updates everywhere!**"
    },
    {
      "file": "src/validation/schemas/homestay.schema.ts",
      "line": 1,
      "title": "Complex Nested Schemas",
      "description": "## Validating Nested Objects\n\n```typescript\nexport const createHomestaySchema = z.object({\n  body: z.object({\n    title: z.string().min(3).max(100),\n    description: z.string().min(10),\n    \n    location: z.object({\n      address: z.string(),\n      district: z.string(),\n      state: z.string(),\n      coordinates: z.object({\n        lat: z.number().min(-90).max(90),\n        lng: z.number().min(-180).max(180)\n      }).optional()\n    }),\n    \n    pricing: z.object({\n      basePrice: z.number().positive(),\n      cleaningFee: z.number().nonnegative().optional(),\n      weekendPrice: z.number().positive().optional()\n    }),\n    \n    amenities: z.array(z.string()).min(1)\n  })\n});\n```\n\n### Schema Breakdown:\n\n**Nested objects:**\n```typescript\nlocation: z.object({ ... })  // Object with its own fields\n```\n\n**Number constraints:**\n```typescript\nz.number().min(-90).max(90)   // Latitude range\nz.number().positive()          // Greater than 0\nz.number().nonnegative()       // 0 or greater\n```\n\n**Arrays:**\n```typescript\nz.array(z.string())           // Array of strings\n  .min(1)                     // At least 1 item required\n```\n\n### Validation Example:\n\n```json\n// This passes:\n{\n  \"title\": \"Mountain View Homestay\",\n  \"location\": {\n    \"address\": \"123 Hill Road\",\n    \"district\": \"Ranchi\",\n    \"state\": \"Jharkhand\"\n  },\n  \"pricing\": { \"basePrice\": 1500 },\n  \"amenities\": [\"WiFi\", \"Breakfast\"]\n}\n\n// This fails:\n{\n  \"title\": \"MV\",                    // Too short (min 3)\n  \"pricing\": { \"basePrice\": -100 }  // Not positive\n}\n```"
    },
    {
      "file": "src/routes/auth/Auth.route.ts",
      "line": 36,
      "title": "Using Validation in Routes",
      "description": "## Putting It All Together\n\n```typescript\nimport { validate } from '../../middleware/validation.middleware';\nimport { registerSchema, loginSchema } from '../../validation';\n\nrouter.post('/register', validate(registerSchema), register);\nrouter.post('/login', validate(loginSchema), login);\n```\n\n### The Request Flow:\n\n```\nPOST /api/v1/auth/register\n    ↓\nvalidate(registerSchema) runs:\n  ├── Parses request body\n  ├── Checks email format\n  ├── Checks password length\n  ├── Checks name presence\n  ├── Applies default role\n  └── If any fail → 400 response\n    ↓ (all passed)\nregister controller runs:\n  Uses validated, type-safe data\n    ↓\nResponse sent\n```\n\n### Benefits of This Pattern:\n\n1. **Controllers stay clean**\n   - No validation code in controllers\n   - Just business logic\n\n2. **Consistent error handling**\n   - Same error format everywhere\n   - Frontend knows what to expect\n\n3. **Type safety**\n   - TypeScript knows data shape\n   - Autocomplete and error checking\n\n4. **Documentation**\n   - Schemas serve as documentation\n   - Clear what each endpoint expects\n\n---\n\n## Tour Complete!\n\nYou now understand request validation with Zod! Continue with Tour 07 to see the complete request flow through the system."
    }
  ]
}
