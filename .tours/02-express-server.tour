{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "02. Express Server Setup",
  "description": "Learn how the Express.js server is configured, middleware is applied, and the application starts up.",
  "steps": [
    {
      "file": "src/server.ts",
      "line": 1,
      "title": "Welcome to the Express Server Tour",
      "description": "## Understanding Web Servers\n\n### What is a Web Server?\n\nA **web server** is a program that:\n1. Listens for incoming requests (like someone ringing a doorbell)\n2. Processes those requests (figures out what they want)\n3. Sends back responses (gives them what they asked for)\n\nEvery time you visit a website, your browser is talking to a web server!\n\n### What is Express.js?\n\n**Express.js** is a framework (a pre-built toolkit) that makes creating web servers in Node.js MUCH easier.\n\nWithout Express, handling a simple web request would require 50+ lines of code. With Express, it's just a few lines.\n\n### What This Tour Covers:\n\n1. How the server file is structured\n2. What each part does and WHY\n3. How requests flow through the system\n4. How to handle errors properly\n\n**By the end, you'll understand every line of this file!**"
    },
    {
      "file": "src/server.ts",
      "line": 1,
      "title": "Import Statements Explained",
      "description": "## Imports: Bringing in External Code\n\n### What are Import Statements?\n\nJust like how you can't cook without ingredients, you can't code without importing the tools you need.\n\n**Import statements** bring in code from:\n- External packages (like `express`)\n- Your own files (like `./routes`)\n\n### Common Import Syntax:\n\n```typescript\n// Import the default export\nimport express from 'express';\n\n// Import specific named exports\nimport { Request, Response } from 'express';\n\n// Import from your own files (starts with ./)\nimport { connectDB } from './config/database';\n```\n\n### Packages vs Local Files:\n\n| Import Path | Where It Comes From |\n|-------------|--------------------|\n| `'express'` | node_modules folder (installed via npm) |\n| `'./routes'` | Your src folder (the ./ means current directory) |\n| `'../config'` | One folder up (../ means parent directory) |\n\n### Why Don't We Write Everything Ourselves?\n\nThe `express` package is 50,000+ lines of tested, debugged code. Using it lets us focus on OUR application's unique features instead of reinventing the wheel."
    },
    {
      "file": "src/server.ts",
      "line": 24,
      "title": "Creating the Express Application",
      "description": "## The Express Application Object\n\n```typescript\nconst app = express();\n```\n\n### What This Line Does:\n\n`express()` is a function that creates a new Express application. The `app` object is now your entire web server!\n\n### What Can the App Object Do?\n\n| Method | Purpose | Example |\n|--------|---------|--------|\n| `app.use()` | Add middleware | `app.use(express.json())` |\n| `app.get()` | Handle GET requests | `app.get('/hello', handler)` |\n| `app.post()` | Handle POST requests | `app.post('/login', handler)` |\n| `app.listen()` | Start the server | `app.listen(5000)` |\n\n### Think of App Like a Restaurant:\n\n- `app` = The entire restaurant\n- `app.use()` = Installing equipment (ovens, fridges)\n- `app.get()` = Items on the menu\n- `app.listen()` = Opening the doors for customers\n\n### Why Use `const`?\n\n`const` means this variable cannot be reassigned. We never want to accidentally replace our app object, so `const` protects us from that mistake."
    },
    {
      "file": "src/server.ts",
      "line": 29,
      "title": "Port Configuration",
      "description": "## Understanding Ports\n\n```typescript\nconst PORT = process.env.PORT || 5000;\n```\n\n### What is a Port?\n\nImagine a building (your computer) with many doors (ports). Each door leads to a different service:\n- Port 80: Standard websites\n- Port 443: Secure websites (HTTPS)\n- Port 27017: MongoDB database\n- Port 5000: Our API server\n\n### Breaking Down the Code:\n\n| Part | Meaning |\n|------|--------|\n| `process.env.PORT` | Read the PORT value from environment variables |\n| `\\|\\|` | \"Or\" - use the next value if first is undefined |\n| `5000` | Default port if none is set |\n\n### Why Not Just Write `5000`?\n\n**Flexibility!** Different environments need different ports:\n\n| Environment | PORT Value | Why |\n|-------------|-----------|-----|\n| Your laptop | 5000 | Developer preference |\n| Test server | 3000 | Avoid conflicts |\n| Production | 80 or 443 | Standard web ports |\n\n### What is process.env?\n\n`process.env` is a built-in Node.js object containing all environment variables. It's like a dictionary of settings:\n\n```javascript\nprocess.env.PORT      // \"5000\"\nprocess.env.NODE_ENV  // \"development\"\nprocess.env.JWT_SECRET // \"super-secret-key\"\n```"
    },
    {
      "file": "src/server.ts",
      "line": 39,
      "title": "JSON Body Parser Middleware",
      "description": "## Parsing Request Bodies\n\n```typescript\napp.use(express.json());\n```\n\n### The Problem This Solves:\n\nWhen a client sends data to your server (like login credentials), it arrives as raw text:\n\n```\nPOST /api/login HTTP/1.1\nContent-Type: application/json\n\n{\"email\":\"john@example.com\",\"password\":\"secret123\"}\n```\n\nWithout a parser, `req.body` would be `undefined` - you couldn't access the email or password!\n\n### What express.json() Does:\n\n1. Checks if request has JSON data\n2. Reads the raw text\n3. Converts it to a JavaScript object\n4. Attaches it to `req.body`\n\n### Before and After:\n\n```javascript\n// WITHOUT express.json():\nconsole.log(req.body);  // undefined\n\n// WITH express.json():\nconsole.log(req.body);  // { email: 'john@example.com', password: 'secret123' }\n```\n\n### What is app.use()?\n\n`app.use()` adds **middleware** to your application. Middleware is code that runs on EVERY request before your route handlers.\n\nThink of middleware as security checkpoints at an airport - every passenger goes through them.\n\n### What is JSON?\n\n**JSON** (JavaScript Object Notation) is a text format for sending data. It looks like JavaScript objects but can be sent over the internet as plain text."
    },
    {
      "file": "src/server.ts",
      "line": 45,
      "title": "URL-Encoded Form Parser",
      "description": "## Parsing HTML Form Data\n\n```typescript\napp.use(express.urlencoded({ extended: true }));\n```\n\n### When Is This Used?\n\nHTML forms send data differently than JSON:\n\n```\nPOST /contact HTTP/1.1\nContent-Type: application/x-www-form-urlencoded\n\nname=John+Doe&email=john%40example.com&message=Hello\n```\n\nThis is **URL-encoded** format - special characters are converted (@ becomes %40).\n\n### What This Middleware Does:\n\n1. Detects form submissions\n2. Decodes the URL-encoded text\n3. Converts to JavaScript object\n4. Attaches to `req.body`\n\n### What Does `extended: true` Mean?\n\n| Option | Capability |\n|--------|--------|\n| `extended: false` | Simple key-value pairs only |\n| `extended: true` | Nested objects and arrays allowed |\n\nExample with `extended: true`:\n```\nuser[name]=John&user[email]=john@example.com\n```\nBecomes:\n```javascript\n{ user: { name: 'John', email: 'john@example.com' } }\n```\n\n### JSON vs URL-Encoded: When to Use Which?\n\n| Format | Used By |\n|--------|--------|\n| JSON | Modern web apps, mobile apps, APIs |\n| URL-encoded | Traditional HTML forms |\n\nWe support BOTH so our API works with any client!"
    },
    {
      "file": "src/server.ts",
      "line": 56,
      "title": "Mounting the API Router",
      "description": "## Route Mounting: Organizing Your API\n\n```typescript\napp.use('/api/v1', apiRouter);\n```\n\n### What is Route Mounting?\n\n**Mounting** attaches a group of routes at a specific path prefix. All routes in `apiRouter` now start with `/api/v1`.\n\n### How Prefixing Works:\n\n| Route in apiRouter | Final URL |\n|-------------------|----------|\n| `/auth/login` | `/api/v1/auth/login` |\n| `/homestays` | `/api/v1/homestays` |\n| `/users/me` | `/api/v1/users/me` |\n\n### Why Prefix with /api?\n\nSeparates API routes from other routes:\n- `/api/v1/users` → Returns JSON data\n- `/about` → Could serve an HTML page\n\n### Why Use /v1?\n\n**API Versioning** protects existing users when you make changes!\n\nScenario: You need to change how `/users` works.\n\n**Without versioning:**\n- You change `/users`\n- ALL apps using your API break immediately!\n\n**With versioning:**\n- Old apps keep using `/api/v1/users` (still works)\n- New apps use `/api/v2/users` (new behavior)\n- You deprecate v1 when everyone has migrated\n\n### What is apiRouter?\n\n`apiRouter` is imported from `./routes`. It's another Express Router that contains all our feature routes (auth, homestays, guides, etc.).\n\nThis keeps `server.ts` clean and organized."
    },
    {
      "file": "src/server.ts",
      "line": 62,
      "title": "Swagger API Documentation",
      "description": "## Automatic API Documentation\n\n```typescript\napp.use('/api/docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec));\n```\n\n### What is API Documentation?\n\nAPI documentation tells developers:\n- What endpoints are available\n- What data to send\n- What responses to expect\n- How to authenticate\n\nWithout good docs, developers have to guess how to use your API!\n\n### What is Swagger?\n\n**Swagger** (also called OpenAPI) is a standard for describing APIs. It creates:\n- Interactive documentation (you can test endpoints in the browser!)\n- Auto-generated client code\n- API specifications for teams\n\n### Accessing the Docs:\n\nWhen the server runs, visit:\n```\nhttp://localhost:5000/api/docs\n```\n\nYou'll see a beautiful, interactive page showing all endpoints!\n\n### How This Line Works:\n\n| Part | Purpose |\n|------|--------|\n| `/api/docs` | URL path for documentation |\n| `swaggerUi.serve` | Serves the static files (CSS, JS) |\n| `swaggerUi.setup(swaggerSpec)` | Renders the documentation UI |\n\n### Why Auto-Generated Docs?\n\nManual documentation gets outdated. By generating docs from code comments, they're always accurate!"
    },
    {
      "file": "src/server.ts",
      "line": 79,
      "title": "404 Not Found Handler",
      "description": "## Handling Unknown Routes\n\n```typescript\napp.use((_req: Request, res: Response) => {\n  res.status(404).json({\n    success: false,\n    message: 'Endpoint not found'\n  });\n});\n```\n\n### What is a 404 Error?\n\n**404 Not Found** means the requested resource doesn't exist. It's the error you see when visiting a broken link.\n\n### Why Do We Need This Handler?\n\nWithout it, Express would send its default error page:\n```html\nCannot GET /unknown-route\n```\n\nThis looks unprofessional and doesn't match our JSON API format.\n\n### How This Works:\n\n1. Request comes in for `/api/v1/nonexistent`\n2. Express checks all defined routes - no match\n3. This catch-all handler runs\n4. Sends consistent JSON error response\n\n### Why is it at the Bottom?\n\n**Order matters in Express!** Routes are checked top-to-bottom.\n\nIf this was at the TOP:\n```\nRequest: GET /api/v1/homestays\n→ Hits 404 handler first\n→ Returns \"not found\" (WRONG!)\n```\n\nAt the BOTTOM:\n```\nRequest: GET /api/v1/homestays\n→ Checks all routes first\n→ Matches homestays route (correct!)\n```\n\n### What Does the Underscore Mean?\n\n`_req` - The underscore tells other developers \"we're not using this parameter.\" It's a convention that improves code readability."
    },
    {
      "file": "src/server.ts",
      "line": 125,
      "title": "Global Error Handler",
      "description": "## Catching All Errors\n\n```typescript\napp.use((err: Error, _req: Request, res: Response, _next: NextFunction) => {\n  // Handle different error types\n});\n```\n\n### Why Global Error Handling?\n\nBugs happen. Databases fail. Without proper handling, errors could:\n- Crash your entire server\n- Leak sensitive information\n- Confuse users with technical messages\n\n### How Express Identifies Error Handlers:\n\nExpress knows this is an error handler because it has **4 parameters** (err, req, res, next). Regular middleware has only 3.\n\n### What Errors Does This Catch?\n\n1. **Thrown errors:** `throw new Error('Something broke')`\n2. **Async rejections:** `await failingFunction()`\n3. **next(error):** When middleware passes errors down\n\n### Error Response Format:\n\n```json\n{\n  \"success\": false,\n  \"message\": \"Something went wrong\"\n}\n```\n\n### Why NOT Show Full Error Details?\n\n**Security!** Error details might reveal:\n- Database structure\n- File paths on your server\n- Library versions (hackers exploit known bugs)\n\nIn production, always show generic messages. Log the full error privately for debugging."
    },
    {
      "file": "src/server.ts",
      "line": 129,
      "title": "Handling Database Errors",
      "description": "## MongoDB-Specific Error Handling\n\n### CastError: Invalid IDs\n\n```typescript\nif (isCastError(err) && err.kind === 'ObjectId') {\n  res.status(400).json({ message: 'Invalid ID format' });\n}\n```\n\n**What is this?** MongoDB IDs have a specific format (24 hex characters). If someone requests `/homestays/invalid-id`, MongoDB throws a CastError.\n\n**Without handling:** Returns confusing technical error\n**With handling:** Returns clear \"Invalid ID format\" message\n\n### Duplicate Key Error\n\n```typescript\nif (isMongoServerError(err) && err.code === 11000) {\n  res.status(409).json({ message: 'Duplicate value' });\n}\n```\n\n**What is this?** When you try to insert data that violates a unique constraint (like duplicate email addresses).\n\n**Error code 11000** is MongoDB's code for duplicate key violations.\n\n**HTTP 409 Conflict** means the request conflicts with existing data.\n\n### Why Handle These Specifically?\n\nDatabase errors are technical and scary for users:\n```\n\"CastError: Cast to ObjectId failed for value 'abc' at path '_id'\"\n```\n\nMuch better:\n```\n\"Invalid ID format\"\n```\n\n### Best Practice:\n\nTranslate technical errors into user-friendly messages that help them fix the problem."
    },
    {
      "file": "src/server.ts",
      "line": 175,
      "title": "Async Server Startup",
      "description": "## Starting the Server Properly\n\n```typescript\nasync function startServer(): Promise<void> {\n  try {\n    await connectDB();\n    app.listen(PORT);\n  } catch (error) {\n    process.exit(1);\n  }\n}\n```\n\n### What is async/await?\n\n**Async/await** is a way to write code that waits for things to complete.\n\nWithout async:\n```javascript\nconnectDB();\napp.listen(5000);  // Runs immediately, before DB connects!\n```\n\nWith async:\n```javascript\nawait connectDB();   // Waits until connected\napp.listen(5000);    // Only runs after DB is ready\n```\n\n### Why Wait for Database?\n\nIf the server starts before the database connects:\n- First user requests will fail\n- Errors will confuse users\n- App appears broken\n\n### What is Promise<void>?\n\n`Promise<void>` means:\n- `Promise` - This function does async work\n- `void` - It doesn't return any value\n\n### What is try/catch?\n\n```javascript\ntry {\n  // Try to do this\n} catch (error) {\n  // If it fails, do this instead\n}\n```\n\n### What is process.exit(1)?\n\n- `process.exit()` - Stops the entire Node.js program\n- `1` - Exit code indicating an error (0 = success)\n\nIf the database fails to connect, there's no point running the server!"
    },
    {
      "file": "src/server.ts",
      "line": 181,
      "title": "Listening for Connections",
      "description": "## Opening for Business\n\n```typescript\napp.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n});\n```\n\n### What app.listen() Does:\n\n1. **Opens the port** - Your computer starts accepting connections on port 5000\n2. **Starts the event loop** - Waits for incoming requests\n3. **Calls the callback** - Logs success message\n\n### The Callback Function:\n\n```typescript\n() => {\n  console.log(`Server running on port ${PORT}`);\n}\n```\n\nThis is an **arrow function** (a short way to write functions). It runs AFTER the server successfully starts.\n\n### Template Literals:\n\n```typescript\n`Server running on port ${PORT}`\n```\n\nBackticks (`) allow embedding variables with `${...}`. This prints:\n```\nServer running on port 5000\n```\n\n### What Happens Under the Hood:\n\n1. Node.js tells the operating system \"I want port 5000\"\n2. OS reserves the port for our application\n3. Any traffic to port 5000 goes to our app\n4. Express converts HTTP requests to `req`/`res` objects\n5. Our routes handle the requests\n\n### What if the Port is Already Used?\n\nYou'll get an error:\n```\nError: listen EADDRINUSE: address already in use :::5000\n```\n\nSolution: Either stop the other program or use a different port."
    },
    {
      "file": "src/server.ts",
      "line": 211,
      "title": "Starting Everything Up",
      "description": "## The Final Step\n\n```typescript\nstartServer();\n```\n\n### What This Single Line Does:\n\nWhen you run `npm run dev`, Node.js:\n1. Reads this file top-to-bottom\n2. Executes all import statements\n3. Creates the Express app\n4. Adds all middleware\n5. Registers all routes\n6. THEN hits this line and actually starts!\n\n### Complete Startup Sequence:\n\n```\nnpm run dev\n    ↓\nNode executes server.ts\n    ↓\nImports are loaded\n    ↓\napp = express() creates the app\n    ↓\nMiddleware is configured\n    ↓\nRoutes are registered\n    ↓\nstartServer() is called\n    ↓\nconnectDB() connects to MongoDB\n    ↓\napp.listen() opens port 5000\n    ↓\n\"Server running on port 5000\" is logged\n    ↓\nReady to handle requests!\n```\n\n### Why Separate startServer Function?\n\nWe could write:\n```javascript\nconnectDB().then(() => app.listen(5000));\n```\n\nBut a named function:\n- Is easier to read\n- Can be tested independently\n- Groups related startup logic\n- Handles errors in one place\n\n---\n\n## Tour Complete!\n\nYou now understand how Express servers work from top to bottom. Continue with Tour 03 to learn about MongoDB and Mongoose!"
    }
  ]
}
