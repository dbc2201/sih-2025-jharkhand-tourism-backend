{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "04. JWT Authentication",
  "description": "Learn how JWT-based authentication works - from registration to protected routes.",
  "steps": [
    {
      "file": "src/routes/auth/Auth.route.ts",
      "line": 1,
      "title": "What is Authentication?",
      "description": "## Understanding Authentication\n\n### The Real-World Analogy:\n\nImagine entering a members-only club:\n1. **Registration** - You sign up and get a membership card\n2. **Login** - You show your card to prove you're a member\n3. **Protected Access** - Only members can enter certain areas\n\nWeb authentication works the SAME way!\n\n### Key Terms:\n\n| Term | Meaning | Example |\n|------|---------|--------|\n| **Authentication** | Proving WHO you are | Entering username/password |\n| **Authorization** | What you're ALLOWED to do | Can you access admin pages? |\n| **Credentials** | Proof of identity | Email + Password |\n| **Session** | Your active login state | Being \"logged in\" |\n\n### How Web Authentication Works:\n\n```\n1. User sends email + password\n2. Server checks if they match\n3. Server creates a \"token\" (digital ID card)\n4. User stores the token (in browser)\n5. User sends token with future requests\n6. Server verifies token to identify user\n```\n\n### What is JWT?\n\n**JWT** stands for **JSON Web Token**. It's a compact, secure way to represent the user's identity.\n\nThink of it as a digitally signed ID card that the server can verify without checking a database."
    },
    {
      "file": "src/routes/auth/Auth.route.ts",
      "line": 36,
      "title": "The Registration Route",
      "description": "## User Registration\n\n```typescript\nrouter.post('/register', validate(registerSchema), register);\n```\n\n### What is HTTP POST?\n\n**HTTP methods** tell the server what you want to do:\n\n| Method | Purpose | Example |\n|--------|---------|--------|\n| GET | Retrieve data | View a user's profile |\n| POST | Create new data | Register a new user |\n| PUT | Update/replace data | Change your password |\n| DELETE | Remove data | Delete your account |\n\n**POST `/register`** = \"I want to CREATE a new user account\"\n\n### Breaking Down the Route:\n\n```typescript\nrouter.post('/register', validate(registerSchema), register);\n        ↑        ↑              ↑                    ↑\n        |        |              |                    └── Controller function\n        |        |              └── Validation middleware\n        |        └── URL path\n        └── HTTP method\n```\n\n### The Middleware Chain:\n\nRequests pass through middleware in ORDER:\n\n```\nRequest arrives\n    ↓\nvalidate(registerSchema)  ← Checks: Is email valid? Password long enough?\n    ↓ (passes)\nregister                   ← Creates the user account\n    ↓\nResponse sent\n```\n\n### What Data is Sent?\n\n```json\n{\n  \"email\": \"student@example.com\",\n  \"password\": \"securePassword123\",\n  \"name\": \"Test Student\"\n}\n```"
    },
    {
      "file": "src/routes/auth/Auth.route.ts",
      "line": 44,
      "title": "The Login Route",
      "description": "## User Login\n\n```typescript\nrouter.post('/login', validate(loginSchema), login);\n```\n\n### The Login Process:\n\n```\n1. User submits email + password\n2. Server finds user by email\n3. Server compares passwords (using bcrypt)\n4. If match: Generate JWT token\n5. If no match: Return \"Invalid credentials\"\n```\n\n### Why \"Invalid Credentials\" for Both Cases?\n\nWe don't say \"Email not found\" or \"Wrong password\" separately.\n\n**Why?** Security! If we said \"Email not found\", hackers could:\n1. Try random emails\n2. Build a list of valid emails\n3. Focus password attacks on those\n\nGeneric errors reveal less information to attackers.\n\n### What is Returned on Success?\n\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"user\": {\n      \"id\": \"507f1f77bcf86cd799439011\",\n      \"email\": \"student@example.com\",\n      \"name\": \"Test Student\",\n      \"role\": \"customer\"\n    },\n    \"token\": \"eyJhbGciOiJIUzI1NiIs...\"\n  }\n}\n```\n\nThe client stores this token and sends it with future requests."
    },
    {
      "file": "src/routes/auth/Auth.route.ts",
      "line": 51,
      "title": "Protected Routes",
      "description": "## Protecting Routes with Authentication\n\n```typescript\nrouter.get('/me', authenticate, getProfile);\n```\n\n### What Makes This Route Protected?\n\nThe `authenticate` middleware! It runs BEFORE `getProfile` and checks if the user is logged in.\n\n### The Authentication Flow:\n\n```\nClient sends request:\nGET /api/v1/auth/me\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIs...\n    ↓\nauthenticate middleware:\n  ├── Is there an Authorization header? → No = 401 error\n  ├── Does it start with \"Bearer \"? → No = 401 error\n  ├── Is the token valid? → No = 401 error\n  └── All good? → Attach user info to request, continue!\n    ↓\ngetProfile:\n  Uses req.user to know WHO is asking\n  Returns THEIR profile data\n```\n\n### What is \"Bearer\"?\n\nIt's a standard format for sending tokens:\n```\nAuthorization: Bearer <token>\n```\n\n\"Bearer\" means \"whoever bears (carries) this token is authenticated.\"\n\n### Why Not Just Send the Token Directly?\n\nThe `Authorization` header can use different schemes:\n- `Bearer` - Token-based (what we use)\n- `Basic` - Username:password encoded\n- `Digest` - More complex hashing\n\nThe prefix tells the server HOW to interpret the value."
    },
    {
      "file": "src/controllers/auth.controller.ts",
      "line": 100,
      "title": "Registration Logic",
      "description": "## Inside the Register Controller\n\n### Step by Step:\n\n**Step 1: Extract Data**\n```typescript\nconst { email, password, name, role } = req.body;\n```\nPulls the data that the user sent.\n\n**Step 2: Check for Existing User**\n```typescript\nconst existingUser = await UserModel.findOne({ email });\nif (existingUser) {\n  return sendError(res, 'Email already registered', 409);\n}\n```\nCan't have two users with the same email!\n\n**Step 3: Create the User**\n```typescript\nconst user = new UserModel({ email, password, name, role });\nawait user.save();\n```\nThe password is automatically hashed by our pre-save hook!\n\n**Step 4: Generate Token**\n```typescript\nconst token = generateToken(user._id, user.role);\n```\nCreates a JWT so they're logged in immediately.\n\n**Step 5: Send Response**\n```typescript\nsendSuccess(res, { user: toUserResponse(user), token }, 201);\n```\n\n### What is HTTP 409?\n\n**409 Conflict** means \"this request conflicts with existing data\" - the email is already taken.\n\n### What is HTTP 201?\n\n**201 Created** means \"successfully created a new resource\" - the user account was made."
    },
    {
      "file": "src/controllers/auth.controller.ts",
      "line": 251,
      "title": "Login Logic",
      "description": "## Inside the Login Controller\n\n### Step by Step:\n\n**Step 1: Find the User**\n```typescript\nconst user = await UserModel.findByEmail(email);\nif (!user) {\n  return sendError(res, 'Invalid credentials', 401);\n}\n```\nLook up user by email, using our custom static method.\n\n**Step 2: Verify Password**\n```typescript\nconst isMatch = await user.comparePassword(password);\nif (!isMatch) {\n  return sendError(res, 'Invalid credentials', 401);\n}\n```\nUse bcrypt to compare the attempt with stored hash.\n\n**Step 3: Update Last Login**\n```typescript\nuser.lastLogin = new Date();\nawait user.save();\n```\nRecord when they logged in (useful for security audits).\n\n**Step 4: Generate Token**\n```typescript\nconst token = generateToken(user._id, user.role);\nsendSuccess(res, { user: toUserResponse(user), token });\n```\n\n### Why Use findByEmail() Instead of findOne()?\n\nRemember `select: false` on passwords? \n\n`findByEmail()` automatically includes `.select('+password')`, so we can verify the password.\n\n### What is HTTP 401?\n\n**401 Unauthorized** means \"I don't know who you are\" - authentication failed."
    },
    {
      "file": "src/middleware/auth.middleware.ts",
      "line": 35,
      "title": "The Authentication Middleware",
      "description": "## JWT Verification Middleware\n\n```typescript\nexport function authenticate(req, res, next) {\n  // 1. Get the Authorization header\n  const authHeader = req.headers.authorization;\n  \n  // 2. Check format\n  if (!authHeader || !authHeader.startsWith('Bearer ')) {\n    return sendError(res, 'Authentication required', 401);\n  }\n  \n  // 3. Extract the token\n  const token = authHeader.split(' ')[1];\n  \n  // 4. Verify the token\n  const decoded = jwt.verify(token, JWT_SECRET);\n  \n  // 5. Attach user info to request\n  req.user = decoded;\n  \n  // 6. Continue to next middleware/route\n  next();\n}\n```\n\n### Understanding Each Step:\n\n**Step 1-2: Header Validation**\nChecks if the request has proper authentication format.\n\n**Step 3: Token Extraction**\n```\n\"Bearer eyJhbGciOiJIUzI1NiIs...\"\n         ↑\n         Split by space, take second part\n```\n\n**Step 4: Token Verification**\n`jwt.verify()` checks:\n- Is the signature valid? (wasn't tampered with)\n- Is it expired? (past the expiration date)\n\n**Step 5: Attach to Request**\nNow controllers can access `req.user.userId` and `req.user.role`!\n\n**Step 6: next()**\nTells Express \"I'm done, continue to the next handler.\""
    },
    {
      "file": "src/middleware/auth.middleware.ts",
      "line": 115,
      "title": "How JWT Tokens Are Created",
      "description": "## Token Generation\n\n```typescript\nexport function generateToken(userId: string, role: string): string {\n  const expiresIn = process.env.JWT_EXPIRES_IN || '7d';\n  \n  return jwt.sign(\n    { userId, role },      // Payload (data to store)\n    JWT_SECRET,            // Secret key for signing\n    { expiresIn }          // Options\n  );\n}\n```\n\n### What Goes INTO a JWT?\n\nA JWT has three parts (separated by dots):\n\n```\neyJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiIxMjMifQ.signature\n└──────────────────┘ └──────────────────────┘ └────────┘\n      Header              Payload              Signature\n```\n\n| Part | Contains | Example |\n|------|----------|--------|\n| Header | Algorithm info | `{\"alg\": \"HS256\"}` |\n| Payload | Your data | `{\"userId\": \"123\", \"role\": \"customer\"}` |\n| Signature | Verification code | Cryptographic hash |\n\n### What is JWT_SECRET?\n\nA secret key only the server knows. It's used to:\n- **Sign** the token (when creating)\n- **Verify** the token (when checking)\n\nIf someone changes the payload, the signature won't match!\n\n### What Does `expiresIn` Do?\n\nTokens automatically expire:\n- `'7d'` = 7 days\n- `'1h'` = 1 hour\n- `'30m'` = 30 minutes\n\nAfter expiration, users must log in again. This limits damage if a token is stolen."
    },
    {
      "file": "src/middleware/auth.middleware.ts",
      "line": 62,
      "title": "Handling Token Errors",
      "description": "## JWT Error Handling\n\n```typescript\ncatch (error) {\n  if (error instanceof jwt.TokenExpiredError) {\n    sendError(res, 'Token expired, please login again', 401);\n  }\n  \n  if (error instanceof jwt.JsonWebTokenError) {\n    sendError(res, 'Invalid token', 401);\n  }\n}\n```\n\n### Common JWT Errors:\n\n| Error Type | Meaning | User Message |\n|------------|---------|-------------|\n| `TokenExpiredError` | Token past its expiration date | \"Session expired, please login again\" |\n| `JsonWebTokenError` | Token is malformed or tampered | \"Invalid token\" |\n| `NotBeforeError` | Token not valid yet (rare) | \"Token not yet valid\" |\n\n### Why Do Tokens Expire?\n\n**Security!** If someone steals a token:\n- No expiration: They have access FOREVER\n- With expiration: They lose access when it expires\n\nShorter expiration = More secure but less convenient.\n\n### What is `instanceof`?\n\nA JavaScript operator that checks if an error is a specific type:\n\n```typescript\nerror instanceof jwt.TokenExpiredError\n// Checks: \"Is this error specifically a TokenExpiredError?\"\n```\n\nThis lets us give specific error messages instead of generic \"Something went wrong.\""
    },
    {
      "file": "src/middleware/auth.middleware.ts",
      "line": 84,
      "title": "Optional Authentication",
      "description": "## When Authentication is Optional\n\n```typescript\nexport function optionalAuth(req, res, next) {\n  try {\n    const authHeader = req.headers.authorization;\n    if (authHeader && authHeader.startsWith('Bearer ')) {\n      const token = authHeader.split(' ')[1];\n      const decoded = jwt.verify(token, JWT_SECRET);\n      req.user = decoded;\n    }\n    next();  // Continue even without token\n  } catch {\n    next();  // Ignore invalid tokens\n  }\n}\n```\n\n### When Would You Use This?\n\nSome routes work for everyone but behave differently for logged-in users:\n\n**Example: Product Listing**\n```\nGuest:      See products\nLogged in:  See products + \"Add to Wishlist\" button\n```\n\n### Difference from `authenticate`:\n\n| Middleware | No Token | Invalid Token | Valid Token |\n|------------|----------|---------------|-------------|\n| `authenticate` | 401 Error | 401 Error | Continues |\n| `optionalAuth` | Continues | Continues | Sets req.user |\n\n### How Controllers Use This:\n\n```typescript\nfunction getProducts(req, res) {\n  const products = await ProductModel.find();\n  \n  if (req.user) {\n    // User is logged in - add wishlist status\n    products.forEach(p => p.inWishlist = checkWishlist(req.user.userId, p.id));\n  }\n  \n  sendSuccess(res, products);\n}\n```\n\n---\n\n## Tour Complete!\n\nYou now understand JWT authentication! Continue with Tour 05 to learn about Role-Based Access Control (RBAC)."
    }
  ]
}
