{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "03. MongoDB & Mongoose",
  "description": "Learn how MongoDB is configured and how Mongoose models define the data structure.",
  "steps": [
    {
      "file": "src/config/database.ts",
      "line": 1,
      "title": "Introduction to Databases",
      "description": "## Why Do We Need a Database?\n\n### The Problem Without Databases:\n\nImagine storing all your users' data in a JavaScript variable:\n\n```javascript\nlet users = [\n  { name: 'John', email: 'john@example.com' },\n  { name: 'Jane', email: 'jane@example.com' }\n];\n```\n\n**What happens when the server restarts?** ALL DATA IS LOST!\n\n### What is a Database?\n\nA **database** is permanent storage for your application's data. It:\n- Survives server restarts\n- Handles multiple users at once\n- Organizes data efficiently\n- Provides fast searching\n\n### Types of Databases:\n\n| Type | Examples | Data Format | Best For |\n|------|----------|-------------|----------|\n| **SQL** | MySQL, PostgreSQL | Tables (rows/columns) | Structured data with relationships |\n| **NoSQL** | MongoDB | Documents (JSON-like) | Flexible, nested data |\n\n### Why MongoDB for This Project?\n\nOur data is naturally hierarchical:\n\n```javascript\n{\n  \"name\": \"Mountain View Homestay\",\n  \"location\": {\n    \"address\": \"123 Hill Road\",\n    \"coordinates\": { \"lat\": 23.4, \"lng\": 85.5 }\n  },\n  \"amenities\": [\"WiFi\", \"Breakfast\", \"Parking\"]\n}\n```\n\nMongoDB stores this EXACTLY as-is. SQL would need multiple tables!"
    },
    {
      "file": "src/config/database.ts",
      "line": 1,
      "title": "What is Mongoose?",
      "description": "## Mongoose: Your MongoDB Best Friend\n\n### The Problem with Raw MongoDB:\n\nMongoDB is flexible - TOO flexible sometimes:\n\n```javascript\n// MongoDB accepts anything!\ndb.users.insert({ name: 'John' });\ndb.users.insert({ naem: 'Jane', emial: 'bad' });  // Typos? No problem!\ndb.users.insert({ completely: 'different structure' });\n```\n\nNo validation, no consistency, chaos!\n\n### What is Mongoose?\n\n**Mongoose** is an **ODM (Object Document Mapper)** - it creates a structured layer on top of MongoDB.\n\n| Without Mongoose | With Mongoose |\n|-----------------|---------------|\n| No structure enforcement | Schemas define structure |\n| No validation | Built-in validation |\n| Raw MongoDB queries | Cleaner, chainable methods |\n| No TypeScript support | Full TypeScript integration |\n\n### What is an ODM?\n\n**O**bject **D**ocument **M**apper - maps JavaScript objects to database documents.\n\nThink of it like a translator:\n- Your Code: \"Create a user with this email\"\n- Mongoose: \"Let me validate that, format it correctly, and talk to MongoDB for you\"\n- MongoDB: Stores the data\n\n### Key Mongoose Concepts:\n\n1. **Schema** - Blueprint defining document structure\n2. **Model** - Factory for creating documents\n3. **Document** - A single data record\n4. **Query** - A way to find/modify data"
    },
    {
      "file": "src/config/database.ts",
      "line": 63,
      "title": "The Connection Function",
      "description": "## Connecting to MongoDB\n\n### What This Function Does:\n\n```typescript\nexport async function connectDB(): Promise<void> {\n  const uri = process.env.MONGO_URI;\n  await mongoose.connect(uri);\n}\n```\n\n### Breaking It Down:\n\n| Part | Meaning |\n|------|--------|\n| `export` | Makes this function usable in other files |\n| `async` | This function does something that takes time (network call) |\n| `connectDB` | Name we chose - describes what it does |\n| `Promise<void>` | Returns a Promise that completes with no value |\n| `process.env.MONGO_URI` | Gets connection string from environment |\n| `mongoose.connect(uri)` | Actually connects to MongoDB |\n\n### What is a Connection String?\n\nA **connection string** (URI) tells Mongoose WHERE the database is and HOW to connect:\n\n```\nmongodb://username:password@localhost:27017/myDatabase\n```\n\n| Part | Meaning |\n|------|--------|\n| `mongodb://` | Protocol (like http://) |\n| `username:password` | Credentials |\n| `localhost` | Database host (your computer for development) |\n| `27017` | MongoDB's default port |\n| `/myDatabase` | Database name |\n\n### Why Use Environment Variables?\n\nDifferent environments need different databases:\n- Development: Local MongoDB on your laptop\n- Testing: Separate test database\n- Production: Cloud MongoDB with real data\n\nEnvironment variables let you change this WITHOUT changing code!"
    },
    {
      "file": "src/models/users/User.model.ts",
      "line": 1,
      "title": "Anatomy of a Mongoose Model",
      "description": "## Understanding Model Files\n\nEvery Mongoose model file typically contains these parts:\n\n### 1. Imports\n```typescript\nimport mongoose, { Document, Schema } from 'mongoose';\nimport bcrypt from 'bcrypt';\n```\n\n### 2. TypeScript Interface\n```typescript\ninterface IUser {\n  email: string;\n  password: string;\n  // ... other fields\n}\n```\n\nDefines what a User looks like in TypeScript.\n\n### 3. Schema Definition\n```typescript\nconst userSchema = new Schema<IUser>({\n  email: { type: String, required: true },\n  // ... field definitions\n});\n```\n\nTells MongoDB what fields to expect and validates them.\n\n### 4. Middleware (Hooks)\n```typescript\nuserSchema.pre('save', function() {\n  // Runs BEFORE saving\n});\n```\n\nAutomatic actions before/after operations.\n\n### 5. Methods\n```typescript\nuserSchema.methods.comparePassword = function() {\n  // Called on individual documents\n};\n```\n\n### 6. Model Export\n```typescript\nexport const UserModel = mongoose.model('User', userSchema);\n```\n\n### Why This Structure?\n\nOrganization! Everything about a User is in one place - easy to find, easy to maintain."
    },
    {
      "file": "src/models/users/User.model.ts",
      "line": 19,
      "title": "TypeScript Interfaces",
      "description": "## Defining Data Types with Interfaces\n\n### What is an Interface?\n\nAn **interface** is a TypeScript feature that describes the SHAPE of an object. It's like a contract saying \"objects of this type MUST have these properties.\"\n\n```typescript\ninterface IUser {\n  email: string;        // Must be text\n  password: string;     // Must be text\n  name: string;         // Must be text\n  role: UserRole;       // Must be one of the defined roles\n  isActive: boolean;    // Must be true or false\n  lastLogin?: Date;     // Optional (? means it can be missing)\n  createdAt: Date;      // Must be a date\n  updatedAt: Date;      // Must be a date\n}\n```\n\n### Why Use Interfaces?\n\n**Without interfaces:**\n```typescript\nfunction greetUser(user) {\n  console.log(user.namee);  // Typo! But no error...\n}\n// Crashes at runtime: \"undefined is not a function\"\n```\n\n**With interfaces:**\n```typescript\nfunction greetUser(user: IUser) {\n  console.log(user.namee);  // ERROR! Property 'namee' doesn't exist\n}\n// Caught at compile time - before you even run the code!\n```\n\n### The I Prefix Convention\n\n`IUser` - The \"I\" prefix is a convention meaning \"Interface\". Some teams use it, some don't. It helps distinguish interfaces from classes.\n\n### Optional Properties\n\nThe `?` makes a property optional:\n```typescript\nlastLogin?: Date;  // User might not have logged in yet\n```"
    },
    {
      "file": "src/models/users/User.model.ts",
      "line": 33,
      "title": "Document Interface with Methods",
      "description": "## Extending the Document Type\n\n```typescript\nexport interface IUserDocument extends IUser, Document {\n  comparePassword(candidatePassword: string): Promise<boolean>;\n}\n```\n\n### What is \"extends\"?\n\nIn TypeScript, `extends` means \"this interface includes everything from those other interfaces, PLUS more.\"\n\nThink of it like inheritance:\n- `IUser` - Has email, password, name, etc.\n- `Document` - Has _id, save(), delete(), etc. (from Mongoose)\n- `IUserDocument` - Has ALL of the above, plus custom methods\n\n### Why Two Interfaces?\n\n| Interface | Purpose | When Used |\n|-----------|---------|----------|\n| `IUser` | Plain data shape | Creating new users, API responses |\n| `IUserDocument` | Full Mongoose document | Working with database records |\n\n### What is Document?\n\n`Document` is a Mongoose type that adds:\n- `_id` - Unique identifier\n- `.save()` - Save changes to database\n- `.delete()` - Remove from database\n- And many more methods...\n\n### Custom Methods\n\n```typescript\ncomparePassword(candidatePassword: string): Promise<boolean>;\n```\n\nThis declares that every User document will have a `comparePassword` method. We'll define the actual function later.\n\n**Why Promise<boolean>?** Password comparison is async (takes time), and returns true/false."
    },
    {
      "file": "src/models/users/User.model.ts",
      "line": 47,
      "title": "Schema Definition Basics",
      "description": "## Creating a Mongoose Schema\n\n```typescript\nconst userSchema = new Schema<IUserDocument>({\n  email: {\n    type: String,\n    required: [true, 'Email is required'],\n    unique: true,\n    lowercase: true,\n    trim: true,\n    match: [/^\\S+@\\S+\\.\\S+$/, 'Invalid email']\n  },\n  // ... more fields\n});\n```\n\n### What is a Schema?\n\nA **schema** is the RULEBOOK for your data. It defines:\n- What fields exist\n- What type each field is\n- What rules each field must follow\n\n### Field Options Explained:\n\n| Option | What It Does | Example |\n|--------|--------------|--------|\n| `type` | Data type | `String`, `Number`, `Date`, `Boolean` |\n| `required` | Must have a value | `[true, 'Custom error message']` |\n| `unique` | No duplicates allowed | `true` |\n| `lowercase` | Convert to lowercase | `'JOHN@EMAIL.COM'` → `'john@email.com'` |\n| `trim` | Remove whitespace | `'  john  '` → `'john'` |\n| `match` | Must match regex pattern | Email validation |\n| `default` | Value if not provided | `default: 'customer'` |\n| `min/max` | Number range | `min: 0, max: 100` |\n| `minlength/maxlength` | Text length | `minlength: 8` |\n\n### What is Regex?\n\n`/^\\S+@\\S+\\.\\S+$/` is a **regular expression** (regex) - a pattern for matching text.\n\nThis one checks for valid email format: `something@something.something`"
    },
    {
      "file": "src/models/users/User.model.ts",
      "line": 61,
      "title": "Password Field Security",
      "description": "## Protecting Sensitive Data\n\n```typescript\npassword: {\n  type: String,\n  required: true,\n  minlength: 8,\n  select: false  // <-- Super important!\n}\n```\n\n### What Does `select: false` Do?\n\nBy default, Mongoose returns ALL fields when you query:\n\n```javascript\nconst user = await UserModel.findById(id);\n// Returns: { email, password, name, ... }\n// BAD: Password is exposed!\n```\n\nWith `select: false`:\n\n```javascript\nconst user = await UserModel.findById(id);\n// Returns: { email, name, ... }\n// GOOD: Password is hidden!\n```\n\n### When Do You Need the Password?\n\nOnly for login verification! Use `.select('+password')` to explicitly include it:\n\n```javascript\n// For login - need password to compare\nconst user = await UserModel.findById(id).select('+password');\n```\n\n### Why Is This Important?\n\nSecurity principle: **Principle of Least Privilege**\n\nDon't give access to sensitive data unless absolutely necessary. Even if you think you won't expose passwords, mistakes happen. This is a safety net.\n\n### Password Storage Rules:\n\n1. NEVER store passwords as plain text\n2. NEVER return passwords in API responses\n3. ALWAYS hash passwords before storing\n4. Use `select: false` as an extra safeguard"
    },
    {
      "file": "src/models/users/User.model.ts",
      "line": 83,
      "title": "Schema Options",
      "description": "## Configuring Schema Behavior\n\n```typescript\n{\n  timestamps: true,\n  collection: 'users'\n}\n```\n\n### What Does `timestamps: true` Do?\n\nAutomatically adds and manages two fields:\n\n| Field | Value | Updated When |\n|-------|-------|-------------|\n| `createdAt` | Date/time created | Only when document is first saved |\n| `updatedAt` | Date/time modified | Every time document changes |\n\nWithout this option, you'd have to manually set these dates every time!\n\n### What Does `collection` Do?\n\nSets the MongoDB collection name.\n\n**Without `collection`:** Mongoose guesses based on model name:\n- Model `'User'` → Collection `'users'` (pluralized, lowercase)\n- Model `'UserDocument'` → Collection `'userdocuments'`\n\n**With `collection: 'users'`:** Always uses `'users'`, no guessing.\n\n### What is a Collection?\n\nIn MongoDB:\n- **Database** = Folder\n- **Collection** = File in that folder\n- **Document** = Line in that file\n\n```\nDatabase: jharkhand-tourism\n├── Collection: users\n│   ├── Document: { _id: 1, name: 'John' }\n│   └── Document: { _id: 2, name: 'Jane' }\n├── Collection: homestays\n└── Collection: bookings\n```"
    },
    {
      "file": "src/models/users/User.model.ts",
      "line": 90,
      "title": "Database Indexes",
      "description": "## Making Queries Fast with Indexes\n\n```typescript\nuserSchema.index({ email: 1 }, { unique: true });\nuserSchema.index({ role: 1 });\n```\n\n### What is an Index?\n\nThink of a book's index at the back - instead of reading every page to find \"JavaScript\", you look in the index and it tells you \"page 42, 67, 103\".\n\nDatabase indexes work the same way!\n\n### Without an Index:\n\n```javascript\nUserModel.find({ email: 'john@example.com' });\n// MongoDB scans EVERY document: \"Is this John? No. Is this John? No...\"\n// With 1 million users = 1 million checks = SLOW\n```\n\n### With an Index:\n\n```javascript\nUserModel.find({ email: 'john@example.com' });\n// MongoDB checks the index: \"John is at position 42\"\n// With 1 million users = 1 lookup = FAST\n```\n\n### Index Options:\n\n| Number | Meaning |\n|--------|--------|\n| `1` | Ascending order (A→Z, 0→9) |\n| `-1` | Descending order (Z→A, 9→0) |\n\n### `{ unique: true }`\n\nMakes the index enforce uniqueness - no two documents can have the same email!\n\n### When to Add Indexes:\n\n- Fields you search by frequently (email, username)\n- Fields you sort by (createdAt, price)\n- Fields in query filters\n\n### Trade-off:\n\nIndexes speed up reads but slow down writes (the index must be updated). Don't index everything!"
    },
    {
      "file": "src/models/users/User.model.ts",
      "line": 96,
      "title": "Pre-save Hook for Password Hashing",
      "description": "## Automatic Password Hashing\n\n```typescript\nuserSchema.pre('save', async function () {\n  if (!this.isModified('password')) return;\n  \n  const salt = await bcrypt.genSalt(12);\n  this.password = await bcrypt.hash(this.password, salt);\n});\n```\n\n### What is a Hook (Middleware)?\n\nA **hook** is code that runs automatically at specific moments:\n- `pre('save')` - Runs BEFORE saving\n- `post('save')` - Runs AFTER saving\n\n### What is Password Hashing?\n\n**Hashing** is one-way encryption:\n\n```\nOriginal:  \"myPassword123\"\nHashed:    \"$2b$12$K9GpZpYP.wCq8nL6vM5x...\"\n```\n\nYou CANNOT reverse a hash back to the original password!\n\n### Why Hash Passwords?\n\nIf hackers steal your database:\n- Plain text: They have everyone's passwords!\n- Hashed: They have useless scrambled text\n\n### What is a Salt?\n\n**Salt** is random data added before hashing:\n\n```\nWithout salt: hash(\"password123\") = \"abc123\" (same for everyone)\nWith salt:    hash(\"password123\" + \"random1\") = \"xyz789\"\n              hash(\"password123\" + \"random2\") = \"def456\"\n```\n\nEven identical passwords produce different hashes!\n\n### What is `this.isModified('password')`?\n\nPrevents re-hashing already hashed passwords:\n\n```javascript\nuser.name = 'New Name';\nawait user.save();  // Would hash the already-hashed password!\n```\n\nWe only hash when the password actually changed."
    },
    {
      "file": "src/models/users/User.model.ts",
      "line": 113,
      "title": "Instance Methods",
      "description": "## Adding Methods to Documents\n\n```typescript\nuserSchema.methods.comparePassword = async function(\n  candidatePassword: string\n): Promise<boolean> {\n  return bcrypt.compare(candidatePassword, this.password);\n};\n```\n\n### What are Instance Methods?\n\n**Instance methods** are functions you can call on individual documents.\n\n```javascript\nconst user = await UserModel.findById(id).select('+password');\nconst isCorrect = await user.comparePassword('attempt123');\n// isCorrect: true or false\n```\n\n### Why Not Just Use `bcrypt.compare()` Directly?\n\n**Encapsulation!** The password comparison logic is:\n- In one place (easy to change)\n- Hidden from controllers (they don't need to know about bcrypt)\n- Named clearly (self-documenting code)\n\n### How `this` Works:\n\nInside an instance method, `this` refers to the document:\n\n```typescript\nuserSchema.methods.comparePassword = function(candidate) {\n  // this = the user document\n  // this.password = that user's hashed password\n  return bcrypt.compare(candidate, this.password);\n};\n```\n\n### Why Not Arrow Functions?\n\n```typescript\n// BAD - arrow function\nuserSchema.methods.comparePassword = async (candidate) => {\n  console.log(this);  // undefined! Arrow functions don't have their own `this`\n};\n\n// GOOD - regular function\nuserSchema.methods.comparePassword = async function(candidate) {\n  console.log(this);  // The user document\n};\n```"
    },
    {
      "file": "src/models/users/User.model.ts",
      "line": 125,
      "title": "Static Methods",
      "description": "## Model-Level Methods\n\n```typescript\nuserSchema.statics.findByEmail = function(\n  email: string\n): Promise<IUserDocument | null> {\n  return this.findOne({ email }).select('+password');\n};\n```\n\n### Instance Methods vs Static Methods:\n\n| Type | Called On | Example | `this` Refers To |\n|------|-----------|---------|------------------|\n| Instance | A document | `user.comparePassword()` | That specific user |\n| Static | The model | `UserModel.findByEmail()` | The UserModel itself |\n\n### When to Use Static Methods:\n\nUse static methods for:\n- Custom queries (like `findByEmail`)\n- Operations that don't need a specific document\n- Factory functions\n\n### This Example:\n\n```typescript\n// Instead of:\nconst user = await UserModel.findOne({ email }).select('+password');\n\n// We can write:\nconst user = await UserModel.findByEmail(email);\n```\n\n### Why Include `.select('+password')`?\n\n`findByEmail` is specifically for login, where we need the password. This saves the controller from knowing about the `select` trick.\n\n### What is `IUserDocument | null`?\n\nTypeScript union type meaning \"either a user document OR null\" (if no user is found)."
    },
    {
      "file": "src/models/users/User.model.ts",
      "line": 134,
      "title": "Creating and Exporting the Model",
      "description": "## The Final Step: Creating the Model\n\n```typescript\nexport const UserModel: IUserModel = mongoose.model<IUserDocument, IUserModel>(\n  'User',\n  userSchema\n);\n```\n\n### What This Does:\n\n1. Takes our schema (rules + methods)\n2. Creates a Model (factory for documents)\n3. Exports it for use in other files\n\n### Breaking Down the Generics:\n\n```typescript\nmongoose.model<IUserDocument, IUserModel>('User', userSchema)\n               ↑                ↑\n               |                └── Model type (includes static methods)\n               └── Document type (includes instance methods)\n```\n\n### The 'User' String:\n\nThis is the **model name**. It's used for:\n1. Collection name (lowercase + plural = 'users')\n2. References between models\n3. Error messages\n\n### How to Use the Model:\n\n```javascript\n// Create a new user\nconst user = new UserModel({ email: 'test@example.com', password: 'secret' });\nawait user.save();\n\n// Find users\nconst users = await UserModel.find({ role: 'admin' });\n\n// Find one user\nconst user = await UserModel.findById(id);\n\n// Update\nawait UserModel.findByIdAndUpdate(id, { name: 'New Name' });\n\n// Delete\nawait UserModel.findByIdAndDelete(id);\n```"
    },
    {
      "file": "src/models/users/User.model.ts",
      "line": 167,
      "title": "Response Transformation",
      "description": "## Safely Preparing Data for API Responses\n\n```typescript\nexport function toUserResponse(user: IUserDocument): UserResponse {\n  return {\n    id: user._id.toString(),\n    email: user.email,\n    name: user.name,\n    role: user.role,\n    isActive: user.isActive,\n    createdAt: user.createdAt\n  };\n}\n```\n\n### Why Not Return the User Document Directly?\n\n**Security and Cleanliness!**\n\nRaw document:\n```json\n{\n  \"_id\": { \"$oid\": \"507f1f77bcf86cd799439011\" },\n  \"email\": \"john@example.com\",\n  \"password\": \"$2b$12$...\",  // EXPOSED!\n  \"__v\": 0,                    // Internal Mongoose field\n  \"createdAt\": \"2024-01-15T...\"\n}\n```\n\nTransformed response:\n```json\n{\n  \"id\": \"507f1f77bcf86cd799439011\",\n  \"email\": \"john@example.com\",\n  \"name\": \"John Doe\",\n  \"role\": \"customer\",\n  \"isActive\": true\n}\n```\n\n### Benefits:\n\n1. **Security** - Password never leaves the server\n2. **Cleanliness** - No internal MongoDB/Mongoose fields\n3. **Consistency** - `id` instead of `_id`\n4. **Control** - Choose exactly what to expose\n\n### `_id.toString()`:\n\nMongoDB `_id` is an ObjectId object. `.toString()` converts it to a simple string for JSON responses.\n\n---\n\n## Tour Complete!\n\nYou now understand MongoDB, Mongoose, schemas, and models! Continue with Tour 04 to learn about authentication."
    }
  ]
}
